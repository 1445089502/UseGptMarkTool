// ==UserScript==
// @name         éšè—æŒ‡å®šå…ƒç´ ï¼ˆè‡ªåŠ¨é…ç½®åŠ è½½ï¼‰
// @namespace    http://tampermonkey.net/
// @version      1.6
// @description  æ ¹æ® URL è‡ªåŠ¨åŠ è½½é…ç½®å¹¶éšè—å…ƒç´ ã€‚æ”¯æŒæ’¤å›ã€é‡åšã€ä¿å­˜ã€æŸ¥çœ‹ã€å»¶è¿Ÿéšè—ç­‰åŠŸèƒ½ã€‚
// @author       è¯—è–° && ChatGPT
// @match        *://*/*
// @grant        none
// ==/UserScript==

(function () {
    'use strict';

    // === è‡ªåŠ¨é…ç½®æ˜ å°„ ===
    const hardcodedConfigMap = [
        {
            matchType: 'exact',
            pattern: '',
            configUrl: ''
        },
        {
            matchType: 'prefix',
            pattern: 'https://5xsq.com/',
            configUrl: 'https://192.168.50.51/SelfTsukuru/TampermonkeyConfig/5xsq.json'
        },
        {
            matchType: 'prefix',
            pattern: 'https://guangdongvideo.com/adult/',
            configUrl: 'https://192.168.50.51/SelfTsukuru/TampermonkeyConfig/fc2.json'
        }
    ];

    function log(msg, ...args) {
        console.log('[éšè—å…ƒç´ ]', msg, ...args);
    }

    let classNamesMap = new Map();
    let hidden = true;
    let previousState = [];
    let actionList = [];
    let currentIndex = -1;

    // === UI åˆ›å»º ===
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'fixed';
    buttonContainer.style.bottom = '10px';
    buttonContainer.style.right = '10px';
    buttonContainer.style.zIndex = 1000;

    const toggleButton = document.createElement('button');
    toggleButton.textContent = 'æ“ä½œé¢æ¿';
    toggleButton.style.marginBottom = '5px';
    buttonContainer.appendChild(toggleButton);

    const panel = document.createElement('div');
    panel.style.display = 'none';
    panel.style.border = '1px solid #ccc';
    panel.style.padding = '10px';
    panel.style.backgroundColor = '#f9f9f9';
    panel.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
    buttonContainer.appendChild(panel);

    const actions = [
        { text: 'éšè—å…ƒç´ ', action: promptClassNameAndParent },
        { text: 'æ’¤å›æ“ä½œ', action: undoLastAction },
        { text: 'é‡åšæ“ä½œ', action: redoLastAction },
        { text: 'ä¿å­˜é…ç½®', action: saveConfig },
        { text: 'åŠ è½½é…ç½®', action: openConfigFile },
        { text: 'æŸ¥çœ‹é…ç½®', action: logCurrentConfig },
        { text: 'å†å²è®°å½•', action: viewActionHistory },
        { text: 'å»¶è¿Ÿéšè—', action: delayedToggle }
    ];

    actions.forEach(({ text, action }) => {
        const btn = document.createElement('button');
        btn.textContent = text;
        btn.style.display = 'block';
        btn.style.marginBottom = '5px';
        btn.addEventListener('click', action);
        panel.appendChild(btn);
    });

    document.body.appendChild(buttonContainer);
    toggleButton.addEventListener('click', () => {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    });

    document.addEventListener('keydown', function (e) {
        if (e.key.toUpperCase() === 'TAB') {
            buttonContainer.style.display = buttonContainer.style.display !== 'none' ? 'none' : 'block';
        }
    });

    // === åŠŸèƒ½ ===
    function promptClassNameAndParent() {
        const input = prompt("è¯·è¾“å…¥è¦éšè—çš„å…ƒç´ çš„ç±»åï¼Œç”¨ç©ºæ ¼æˆ–å›è½¦åˆ†éš”:");
        const newClassNames = input.split(/\s+/).filter(name => name.trim() !== '');
        const newParentLevels = parseInt(prompt("è¯·è¾“å…¥è¦éšè—çš„çˆ¶çº§æ•°:"), 10);
        if (newClassNames.length > 0 && newParentLevels >= 0) {
            newClassNames.forEach(className => {
                classNamesMap.set(className, newParentLevels);
            });
            actionList = actionList.slice(0, currentIndex + 1);
            actionList.push({ type: 'hide', classNames: newClassNames, parentLevels: newParentLevels });
            currentIndex++;
            toggleElements(newClassNames, newParentLevels);
        }
    }

    function toggleElements(classNamesToToggle, parentLevelsToToggle) {
        if (classNamesToToggle.length === 0 || parentLevelsToToggle < 0) return;
        const currentState = [];

        classNamesToToggle.forEach(className => {
            const elements = document.querySelectorAll(`.${className}`);
            console.log(`ğŸ” æŸ¥æ‰¾ç±»å .${className}ï¼Œæ‰¾åˆ° ${elements.length} ä¸ªå…ƒç´ `);
            elements.forEach(function (element) {
                let parent = element;
                for (let i = 0; i < parentLevelsToToggle; i++) {
                    if (parent) parent = parent.parentElement;
                }
                if (parent) {
                    currentState.push({ element: parent, display: parent.style.display });
                    if (hidden) {
                        parent.style.setProperty('display', 'none', 'important');
                    } else {
                        parent.style.removeProperty('display');
                    }
                }
            });
        });

        previousState.push([...currentState]);
    }

    function undoLastAction() {
        if (currentIndex >= 0) {
            const lastAction = actionList[currentIndex];
            if (lastAction.type === 'hide') {
                previousState[currentIndex].forEach(({ element, display }) => {
                    element.style.display = display;
                });
                lastAction.classNames.forEach(className => classNamesMap.delete(className));
                previousState.pop();
            }
            currentIndex--;
            logCurrentConfig();
        }
    }

    function redoLastAction() {
        if (currentIndex < actionList.length - 1) {
            currentIndex++;
            const nextAction = actionList[currentIndex];
            if (nextAction.type === 'hide') {
                toggleElements(nextAction.classNames, nextAction.parentLevels);
                nextAction.classNames.forEach(className => {
                    classNamesMap.set(className, nextAction.parentLevels);
                });
            }
            logCurrentConfig();
        }
    }

    function viewActionHistory() {
        console.log('ğŸ“œ è¡Œä¸ºè®°å½•:', actionList);
    }

    function openConfigFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.style.display = 'none';
        input.addEventListener('change', handleFileSelect);
        document.body.appendChild(input);
        input.click();
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const data = JSON.parse(e.target.result);
                applyConfig(data);
            };
            reader.readAsText(file);
        }
    }

    function saveConfig() {
        const data = { classNamesMap: [...classNamesMap] };
        const url = getFileName();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = url;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function logCurrentConfig() {
        console.log('âš™ï¸ å½“å‰é…ç½®:', [...classNamesMap]);
    }

    function getFileName() {
        const hostname = window.location.hostname.replace(/\./g, '_');
        return `${hostname}.json`;
    }

    // === è‡ªåŠ¨åŠ è½½é…ç½®é€»è¾‘ ===
    function fetchAndApplyConfig(url) {
        fetch(url)
            .then(res => {
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return res.json();
            })
            .then(data => {
                applyConfig(data);
                console.log('âœ… è‡ªåŠ¨åŠ è½½é…ç½®æˆåŠŸ:', data);
            })
            .catch(err => {
                console.error('âŒ è‡ªåŠ¨åŠ è½½é…ç½®å¤±è´¥:', err);
            });
    }

    function applyConfig(data) {
        if (data.classNamesMap && Array.isArray(data.classNamesMap)) {
            classNamesMap.clear();
            data.classNamesMap.forEach(([className, parentLevel]) => {
                classNamesMap.set(className, parentLevel);
                toggleElements([className], parentLevel);
            });
            logCurrentConfig();
        }
    }

    function checkAndAutoLoadConfig() {
        const currentUrl = window.location.href;
        for (const rule of hardcodedConfigMap) {
            if (
                (rule.matchType === 'exact' && currentUrl === rule.pattern) ||
                (rule.matchType === 'prefix' && currentUrl.startsWith(rule.pattern))
            ) {
                console.log(`ğŸ§© åŒ¹é…è§„åˆ™æˆåŠŸï¼Œæ­£åœ¨åŠ è½½é…ç½®: ${rule.configUrl}`);
                fetchAndApplyConfig(rule.configUrl);
                break;
            }
        }
    }

    // âœ… å»¶è¿Ÿéšè—åŠŸèƒ½
    function delayedToggle() {
        const delaySeconds = parseInt(prompt("å»¶è¿Ÿå¤šå°‘ç§’åæ‰§è¡Œéšè—ï¼Ÿ", "1"), 10);
        if (isNaN(delaySeconds) || delaySeconds < 0) {
            alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—ï¼");
            return;
        }

        console.log(`â³ ${delaySeconds} ç§’åå¼€å§‹æ‰§è¡Œéšè—...`);
        setTimeout(() => {
            classNamesMap.forEach((parentLevel, className) => {
                toggleElements([className], parentLevel);
            });
            console.log('âœ… å»¶è¿Ÿéšè—æ‰§è¡Œå®Œæ¯•');
        }, delaySeconds * 1000);
    }

    // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨æ£€æŸ¥
    window.addEventListener('load', checkAndAutoLoadConfig);
})();
